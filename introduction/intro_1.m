%% Signals and Systems - Introduction 1

clc
clear
close all

%% 1) Recreate 2 mod() functions

% Try to implement the modulo function mod() on your own. Hint: One 
% possible solution makes use of the function floor(). Of course there are 
% multiple ways to solve this problem. Try to find at least two.

disp("mod1() result:")
disp(mod1(488, 56))
disp("mod2() result:")
disp(mod2(488, 56))

%% 2) Sum of Divisible Numbers

% If we list all the natural numbers below 20 that are multiples of 3 or 5 
% (but not both!), we get 3, 5, 6, 9, 10, 12, 18. The sum of these 
% multiples is 63. Find the sum of all the multiples of 3 or 5 below 1234. 
% The solution has 6 digits and ends with 813.

disp('nat_nums() result:')
disp(nat_nums(1234))

%% 3) Largest Sum

% Find the largest sum of five consecutive digits in the string. 
% s = '731671765313306192251196744';

s = '731671765313306192251196744';
s_list = split(s,'');
s_list = s_list(2:end-1);
s_nums=zeros(size(s_list));
for i=1:length(s_list)
    s_nums(i) = str2double(char(s_list(i)));
end
max_sum = 0;
for i=1:length(s_nums)-4
    sum_ = s_nums(i) + s_nums(i+1) + s_nums(i+2) + s_nums(i+3) + s_nums(i+4);
    if sum_>max_sum
        max_sum = sum_;
    end
end
disp('Largest sum of 5 consecutive digits in 731671765313306192251196744:')
disp(max_sum)

%% 4) Largest Prime Number

% The prime factors of 13195 are 5, 7, 13 and 29. What is the largest prime 
% factor of the number 23461139? The solution has 4 digits and ends with 
% 03.

N = 23461139;
prime_list = primes(sqrt(N));
disp(length(prime_list))
prime_fac_list = zeros(1,1);
counter = 1;
for i=1:length(prime_list)
    if mod1(N, prime_list(i))==0
        prime_fac_list(counter) = prime_list(i);
        counter = counter + 1;
    end
end
disp('Largest prime numbers:')
disp(prime_fac_list)

%% 5) Fibonacci Sequence

% Each new term in the Fibonacci sequence is generated by adding the 
% previous two terms. By starting with 0 and 1, as the first two numbers, 
% the first 10 terms will be: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55. 
% How many terms are smaller than nine million? What is the number of the 
% last term smaller than nine million? (It has seven digits and starts with 
% 5702) Find the sum of all the even-valued terms in the sequence, which 
% does not exceed nine million. (It has 7 digits and starts with 4613)

fib_sequence = [0 1];
max = 9000000;
while fib_sequence(end)+fib_sequence(end-1)<max
    fib_sequence(end+1) = fib_sequence(end-1) + fib_sequence(end);
end
fib_sequence_even = 0;
for i=1:length(fib_sequence)
    if mod1(fib_sequence(i), 2)==0
        fib_sequence_even = fib_sequence_even + fib_sequence(i);
    end
end
disp('Last Fibonacci term smaller than 1,000,000:')
disp(fib_sequence_even)

%% 6) Sieve of Eratosthenes

% By listing the first few prime numbers: 2, 3, 5, 7, 11, and 13, we can 
% see that the 4th prime is 7. What is the 4502nd prime number? Do not use 
% the Matlab isprime() function! The solu-tion has 5 digits and ends with 
% 067. Hint: You could try to use the isprime function from task 4 but it 
% might be too slow. A better idea is to build a Sieve of Eratosthenes.

n = 100000;
p = [0 2:n];   
for k = 2:sqrt(n)
    if p(k)   
        p(k^2:k:n) = 0;
    end
end
p = p(p ~= 0);
disp('The 4502nd prime number:')
disp(p(4502))

%% 7) Sum of Primes

% The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17. Find the sum of all 
% the primes below 58273. The solution starts with 1626.

% Find all primes below n
n = 58273;
prime_numbers = zeros(1,1);
prime_counter = 1;
for i=2:n
    if isprime(i)   
        prime_numbers(prime_counter) = i;
        prime_counter = prime_counter + 1;
    end
end
fprintf('Sum of all primes under %d:\n',n)
disp(sum(prime_numbers))

%% 8) Smallest Common Product

% 2520 is the smallest number that can be divided by each of the numbers 
% from 1 to 10 without any remainder. What is the smallest positive number 
% that is evenly divisible by all of the numbers from 1 to 14? The result 
% has 6 digits and ends with 360.

stop_cond = false;
max = 14;
counter = max;
remainders = zeros(max);
while ~stop_cond
    counter = counter + 1;
    for i=1:max
        remainders(i) = mod1(counter, i);
    end
    if remainders==zeros(max) 
        stop_cond = true;
    end
end
disp('Smallest positive number divisible by all numbers between 1 and 14:')
disp(counter)

%% 9) Compbinations of Array

% In the 5*5 grid below, three numbers along a diagonal line and three 
% numbers along a vertical line are bold.
% d = [ 08 02 $22  97  38 
%       49 14  99 $40  17 
%      $81 18  57  60 $87 
%      $17 40  98  43  69 
%      $48 04  56  62  00]; 
% Their sum is 22 + 40 + 87 = 149 and 81 + 17 + 48 = 164. From all the 
% possible combination (how many are there?) along the horizontal, vertical 
% and both diagonal directions, what is the largest sum you can build with 
% three consecutive num-bers? What is the smallest product?

d = [08 02 22 97 38 
     49 14 99 40 17 
     81 18 57 60 87 
     17 40 98 43 69 
     48 04 56 62 00];
counter = 0;
hor_sum_max = 0;
ver_sum_max = 0;
dia_sum_max = 0;
hor_sum_min = 10000000;
ver_sum_min = 10000000;
dia_sum_min = 10000000;
% Horizontal
for j=1:5
    for i=1:3
        hor_sum = d(j, i) + d(j, i+1) + d(j, i+2);
        if hor_sum>hor_sum_max
            hor_sum_max = hor_sum;
        end
        if hor_sum<hor_sum_min
            hor_sum_min = hor_sum;
        end
        counter = counter + 1;
    end
end
% Vertical
for j=1:3
    for i=1:5
        ver_sum = d(j, i) + d(j+1, i) + d(j+2, i);
        if ver_sum>ver_sum_max
            ver_sum_max = ver_sum;
        end
        if ver_sum<ver_sum_min
            ver_sum_min = ver_sum;
        end
        counter = counter + 1;
    end
end
% DiagonalR
for j=1:3
    for i=1:3
        dia_sum = d(j, i) + d(j+1, i+1) + d(j+2, i+2);
        if dia_sum>dia_sum_max
            dia_sum_max = dia_sum;
        end
        if dia_sum<dia_sum_min
            dia_sum_min = dia_sum;
        end
        counter = counter + 1;
    end
end
% DiagonalL
for j=1:3
    for i=1:3
        dia_sum = d(j, i+2) + d(j+1, i+1) + d(j+2, i);
        if dia_sum>dia_sum_max
            dia_sum_max = dia_sum;
        end
        if dia_sum<dia_sum_min
            dia_sum_min = dia_sum;
        end
        counter = counter + 1;
    end
end
% Possible Combinations
disp('Number of combinations:')
disp(counter)
% Maximum Sum
disp('Maximum Sum:')
disp(hor_sum_max+ver_sum_max+dia_sum_max)
% Minimum Product
disp('Minimum Product:')
disp(hor_sum_min*ver_sum_min*dia_sum_min)

%% 10) Collatz Problem

% The following iterative sequence is defined for the set of positive 
% integers: 
% n -> n/2 (if n is even) 
% n -> 3n + 1 (if n is odd) 
% Using the rule above and starting with 13, we generate the following 
% sequence: 
% 13 -> 40 -> 20 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1 
% It can be seen that this sequence (starting at 13 and finishing at 1) 
% contains 10 terms. Although it has not been proved yet (Collatz Problem), 
% it is thought that all starting numbers finish at 1. Which starting 
% number (under 400000) produces the longest chain? The number ends with 
% 631 and has 6 digits. 
% Hint: First write a function, which generates a sequence for a single 
% given number and return the number of terms.
% Try to improve the runtime by saving some intermediate results.

counter_max = 0;
max_num = 0;
for i=2:400000
    counter = collatz(i);
    if counter>counter_max
        counter_max = counter;
        max_num = i;
    end
end
disp('Longest chain of terms:')
disp(counter_max)
disp('Number with maximum chain:')
disp(max_num)

%% 11) Factorials

% The expression n! means n * (n-1) * ... 3 * 2 * 1 This is known as the 
% factorial of n. Find the sum of the digits in the number 73! 
% Hint: The numbers are way too large for Matlab, so you have to use a 
% vector to store the digits of the number. As a consequence you must also 
% implement your own addition/multiplication/â€¦ operations, which work with 
% such vectors.

% Factorial
n = 73;
int_prod = convert_number_2_list(1);
% Iterate through numbers within factorial range
for i=2:n 
    % Perform list-wise long multiplication
    i_list = convert_number_2_list(i);
    int_prod = list_mult(int_prod, i_list);
end
factorial_n = int_prod;
disp('Factorial of n:')
disp(factorial(n))
disp('Sum of Factorial digits:')
disp(sum(factorial_n, "all"))

%% Functions

function remainder = mod1(num, divisor)
% mod1() finds remainder in a division operation using in-built floor()
% Inputs:
%   num         : dividend
%   divisor     : divisor
%
% Outputs:
%   remainder   : remainder

% Calculate Quotient
quotient = num/divisor;
% Calculate remainder as difference of original number and product of 
% rounded-down quotient and divisor 
remainder = num - divisor*floor(quotient);

end

function remainder = mod2(num, divisor)
% mod2() finds remainder in a division operation w/o using in-built floor()
% order
% Inputs:
%   num         : dividend
%   divisor     : divisor
%
% Outputs:
%   remainder   : remainder

% Calculate quotient and convert to a string
quotient_str = num2str(num / divisor);
% Truncate quotient at decimal point (round down)
quotient_list = split(quotient_str,'.');
% Calculate remainder
remainder = num - divisor*str2double(quotient_list(1));

end

function sum_list = nat_nums(ceiling)
% nat_nums() creates a sum of all natural numbers within a max number that
% are divisible by 3 or 5 but not both
% order
% Inputs:
%   ceiling     : maximum number to search for natural numbers
%
% Outputs:
%   sum_list    : sum of all natural numbers less than 'ceiling'

% Create empty list
list = zeros(1,1);
% Iterate through all numbers under ceiling
for c = 1:ceiling-1
    % Save to list if conditions for natural numbers are met
    if mod1(c, 3)==0 || mod1(c, 5)==0
        if mod1(c, 3)~=mod1(c, 5)
            list = [list; c];
        end
    end
end
sum_list = sum( list , "all" );

end

function counter = collatz(num)
% collatz() performs a functions of a collatz problem
% order
% Inputs:
%   num         : starting number for a collatz problem
%
% Outputs:
%   counter     : number of operations to perform to tranform starting
%                 number into 1

% Create counter to count number of operations performed
counter = 1;
% Iterate through operations until num is transformed to 1
while num~=1
    if mod1(num, 2)==0
        num = num/2;
        counter = counter + 1;
    else
        num = 3*num +1;
        counter = counter + 1;
    end
end

end

function num_list = convert_number_2_list(num)
% convert_number_2_list() creates a list of digits of a number in reverse
% order
% Inputs:
%   num         : a number to convert to a list
%
% Outputs:
%   num_list    : digits of num in a list, in reverse order

% Convert num to string
num_str = num2str(num);
% Split number string into list of strings of the digits
num_str_list_raw = split(num_str,'');
% Trim off empty values in the begining and end of string list
num_str_list_rev = num_str_list_raw(2:length(num_str_list_raw)-1);
% Reverse the order of the list of digits
num_str_list = flip(num_str_list_rev , 1);
% Convert the strings of digits into digits
num_list = zeros(1,1);
for i=1:length(num_str_list)
    num_list(i) = str2double(num_str_list(i));
end

end

function product = list_mult(num_1, num_2)
% list_mult() performs long mulitplication on numbers formated as lists.
% The lists must contain single digits and be in reverse order.
% Inputs:
%   num_1       : number in reverse digit list form
%   num_2       : number in reverse digit list form
%
% Outputs:
%   product     : product of numbers, returnd also in a reverse digit list

% Digit-wise mulitplication of num_1 and num_2, long division ill result in
% higher dimensionality
elem_mult_array = zeros(1,1);
% Element-wise Multiplication
for i=1:length(num_2)
    for j=1:length(num_1)
        elem_mult_array(i, j) = num_1(j)*num_2(i);
    end
end
% Reshape the product matrix
product_arr = zeros(size(elem_mult_array,1),size(elem_mult_array, 2)); % Fix here
for i=1:size(elem_mult_array, 1)
    product_arr(i,i:size(elem_mult_array,2)+(i-1)) = elem_mult_array(i, 1:end);
end
% Add all columns
product_list = zeros(1, size(product_arr,2));
for j=1:size(product_arr,2)
    product_list(1,j) = sum(product_arr(1:end,j));
end
% Singularize the every element within the product list
product = zeros(size(product_list,1),size(product_list,2));
remainder = 0;
for g=1:size(product_list,2)
    product_list(g) = product_list(g) + remainder;
    product(g) = mod1(product_list(g), 10);
    remainder = (product_list(g) - mod1(product_list(g), 10))/10;
end
if remainder>0
    product(size(product_list,2)+1) = remainder;
end
    
end
